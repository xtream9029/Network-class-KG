과제 완성도:미완성 (우선순위 가장 높은 프로세스는 찾아서 실행시켜주지만 aging을 완전히 구현하지못함.)

scheduler() 코드설명:
  ***코드에서 가장 핵심적인 부분만 떼어냄***
      struct proc * highP=0;
      struct proc * LowP=0;
      highP,LowP=p;
      for(p1=ptable.proc; p1<&ptable.proc[NPROC];p1++){//우선순위가 높으면서 nice 값이 같은 두 프로세스 처리가 안됨:왜 안되는지 이유를 아직 못 알아냄
          if(p1->state != RUNNABLE)
            continue;
          if(highP->nice > p1->nice){ // nice값을 두 테이블을 비교해가면서 highP(우선순위가 가장 높은 프로세스)를 찾음
            highP = p1;//여기서 돌아갈 프로세스 결정 우선순위 제일 높은 프로세스로 세팅되기 때문에
            HighPpid=p1->pid;
            HighPnice=p1->nice;
          }
          if(highP->nice==p1->nice) ;//사실 위에 if 조건만으로도 nice값이 같은 경우에 대해서 처리가 되어야 맞는건데 이상하게 snice를 실행시에 
          //우선순위와 가장 높은 프로세스의 nice값과 똑같은 nice값을 다른 프로세스에게 줄때 snice실행시 출력이 되다 멈춰버린다.
          //이것을 스케줄러가 다음으로 스케줄링할 프로세스를 못 결정 한거라고 생각했지만 아무리 생각해봐도 어떻게든 스케줄링할 프로세스가 정해지기때문에 아직도 해결을 못한 부분이다.
          //그래서 같은 경우의 조건을 어거지로 따로 만들어서 그냥 ;로 아무것도 안하게 했는데도 해결되지 않았다.
      }

      for(p2=ptable.proc;p2<&ptable.proc[NPROC];p2++){//이 for문은 우선순위가 가장 낮은 프로세스를 찾는 부분
        if(p2->state!=RUNNABLE)
          continue;
        if(LowP->nice <p2->nice){//우선순위가 가장 낮은 프로세스의 정보를 담아둠.물론 LowPpid,LowPnice변수는 int형 변수
          LowP=p2;
          LowPpid=p2->pid;
          LowPnice=p2->nice;
        }
      }
      if(p->pid==LowPpid && p->nice==LowPnice ) --(LowP->nice);//현재 테이블을 돌다가 우선순위 가장낮은 프로세스를 만나면 그 프로세스의 nice값을 감소시킴(우선순위를 높임)->성공
      if(p->pid==HighPpid&& p->nice==HighPnice) ++(highP->nice);//현재 테이블을 돌다가 우선순위 가장높은 프로세스를 만나면 그 프로세스의 nice값을 증가시킴(우선순위를 높임)->실패
     //ps 할때마다 우선순위가 가장 높은 프로세스는 서서히 nice값이 감소가됨 그런데 그 반대는 실패했고 우선순위가 가장 높은 프로세스가 계속돌고 nice값이 변하지 않았다.
       //최종 스케줄링될 프로세스 결정-->실패
       if(LowP->nice > highP->nice) p=highP;
       else p=LowP;//될줄알고 동작해봤는데 안됨.

*starvation을 방지하기 위한 aging 방법으로는 위에 설명한것처럼 우선순위가 가장 낮은 프로세스는 nice값이 가장 클것이므로 이 프로세스의 nice값을 ps를 실행할때마다 작아지게 확인할수 있게금 했다.
(사실 결과적으로 ps실행할때마다 감소하는거지 왜 ps를 실행할때마다 1씩 안줄고 무작위 숫자만큼 주는지는 모르겠다. nice값이 감소하긴 감소함.)..끝(실행되는 aging은 이게 전부)

Priority-based scheduler 테스트 방법:loop라는 그냥 아무것도안하고 무한 loop를 도는 프로그램을 만들어서 백그라운드 프로그램으로 한 2~3개정도 돌리면서 각각 loop 프로그램의 nice값을 변경시켜가며
테스트 해봤다.

***이 Scheduler의 문제점과 원인
:일단 내 스케줄러의 문제는 첫번째로 우선순위가 가장 높은 프로세스의 nice값을 다른 프로세스에게 세팅할시에 snice출력시 xv6가 멈춰버려서 우선순위가 가장 높으면서 같은 프로세스들에 대해 테스트를 할수
 없다는 점.(왜 그런지 모르겠음,안될 이유가 없는데 당연히 highP->nice > p1->nice에서 같으면 실행이 안되니까 기존 highP가 running이 나와야되는데 그것도 확인할수 없엇음->멈춰버려서)
 우선순위가 가장 낮은 프로세스의 nice값을 다른 프로세스에게 세팅하면 이때는 멈추지않음 우선순위가 가장 높은 프로세스의 nice값을 다른 프로세스에게 세팅할시 멈춤.
 
 그다음 문제점으로는 aging이 실현이 안된다는것,우선순위 낮은 프로세스의 nice값만 줄어들지 실제 nice값이 바뀌면서 그 낮은 프로세스가 실행되게 했다거나 그런게 없음.여러가지로 굉장히 많은 시도를 해봤지만 
 다 실패함.결국 우선순위 가장 높은 프로세스 1개만 계속 도는 결과가 나옴.
 

